/*********************************************
Project : Test software
**********************************************
Chip type: ATmega164A
Clock frequency: 20 MHz
Compilers:  CVAVR 2.x
*********************************************/

#include <mega164a.h>

#include <stdio.h>
#include <delay.h>  
#include <string.h> 
#include <stdlib.h>
#include "defs.h"    
// Bit-Banged I2C Bus functions
#include <i2c.h>

// Graphic Display functions
#include <glcd.h>
#include <io.h>
#include <font5x7.h>
#include "arial14.h"
#include "arial_bold14.h"
#include "courier7x14.h"
#include "courier_bold14.h"
#include "script19.h"
#include "arial14.c"
//#include "arial_bold14.c"
#include "courier7x14.c"
#include "courier_bold14.c"
#include "script19.c"

//*************************************************************************************************
//*********** BEGIN SERIAL STUFF (interrupt-driven, generated by Code Wizard) *********************
//*************************************************************************************************

#ifndef RXB8
#define RXB8 1
#endif

#ifndef TXB8
#define TXB8 0
#endif

#ifndef UPE
#define UPE 2
#endif

#ifndef DOR
#define DOR 3
#endif

#ifndef FE
#define FE 4
#endif

#ifndef UDRE
#define UDRE 5
#endif

#ifndef RXC
#define RXC 7
#endif

#define FRAMING_ERROR (1<<FE)
#define PARITY_ERROR (1<<UPE)
#define DATA_OVERRUN (1<<DOR)
#define DATA_REGISTER_EMPTY (1<<UDRE)
#define RX_COMPLETE (1<<RXC)
//***********************************************************************
#define DHT11_PORT PORTB
#define DHT11_PORTPIN PORTB0 
#define DHT11_DDR DDRB
#define DHT11_DDRPIN DDB0 
#define DHT11_PINPORT PINB
#define DHT11_PIN PINB0 

#define DHT11_INPUT_MODE() DHT11_DDR&=~(1<<DHT11_DDRPIN)
#define DHT11_OUTPUT_MODE() DHT11_DDR|=(1<<DHT11_DDRPIN)
#define DHT11_LOW() DHT11_PORT&=~(1<<DHT11_PORTPIN)
#define DHT11_HIGH() DHT11_PORT|=(1<<DHT11_PORTPIN)

#define DHTLIB_OK                               0
#define DHTLIB_ERROR_CHECKSUM                    -1
#define DHTLIB_ERROR_TIMEOUT                    -2

int read_dht11(int *temp,int *humidity);
int temp=0;
int humidity=0;
int status=0;
//**************************************************************************
// USART0 Receiver buffer
#define RX_BUFFER_SIZE0 8
char rx_buffer0[RX_BUFFER_SIZE0];

#if RX_BUFFER_SIZE0 <= 256
unsigned char rx_wr_index0,rx_rd_index0,rx_counter0;
#else
unsigned int rx_wr_index0,rx_rd_index0,rx_counter0;
#endif

// This flag is set on USART0 Receiver buffer overflow
bit rx_buffer_overflow0;

// USART0 Receiver interrupt service routine
interrupt [USART0_RXC] void usart0_rx_isr(void)
{
char status,data;
status=UCSR0A;
data=UDR0;
if ((status & (FRAMING_ERROR | PARITY_ERROR | DATA_OVERRUN))==0)
   {
   rx_buffer0[rx_wr_index0++]=data;
#if RX_BUFFER_SIZE0 == 256
   // special case for receiver buffer size=256
   if (++rx_counter0 == 0) rx_buffer_overflow0=1;
#else
   if (rx_wr_index0 == RX_BUFFER_SIZE0) rx_wr_index0=0;
   if (++rx_counter0 == RX_BUFFER_SIZE0)
      {
      rx_counter0=0;
      rx_buffer_overflow0=1;
      }
#endif
   }
}

#ifndef _DEBUG_TERMINAL_IO_
// Get a character from the USART0 Receiver buffer
#define _ALTERNATE_GETCHAR_
#pragma used+
char getchar(void)
{
char data;
while (rx_counter0==0);
data=rx_buffer0[rx_rd_index0++];
#if RX_BUFFER_SIZE0 != 256
if (rx_rd_index0 == RX_BUFFER_SIZE0) rx_rd_index0=0;
#endif
#asm("cli")
--rx_counter0;
#asm("sei")
return data;
}
#pragma used-
#endif

// USART0 Transmitter buffer
#define TX_BUFFER_SIZE0 8
char tx_buffer0[TX_BUFFER_SIZE0];

#if TX_BUFFER_SIZE0 <= 256
unsigned char tx_wr_index0,tx_rd_index0,tx_counter0;
#else
unsigned int tx_wr_index0,tx_rd_index0,tx_counter0;
#endif

// USART0 Transmitter interrupt service routine
interrupt [USART0_TXC] void usart0_tx_isr(void)
{
if (tx_counter0)
   {
   --tx_counter0;
   UDR0=tx_buffer0[tx_rd_index0++];
#if TX_BUFFER_SIZE0 != 256
   if (tx_rd_index0 == TX_BUFFER_SIZE0) tx_rd_index0=0;
#endif
   }
}

#ifndef _DEBUG_TERMINAL_IO_
// Write a character to the USART0 Transmitter buffer
#define _ALTERNATE_PUTCHAR_
#pragma used+
void putchar(char c)
{
while (tx_counter0 == TX_BUFFER_SIZE0);
#asm("cli")
if (tx_counter0 || ((UCSR0A & DATA_REGISTER_EMPTY)==0))
   {
   tx_buffer0[tx_wr_index0++]=c;
#if TX_BUFFER_SIZE0 != 256
   if (tx_wr_index0 == TX_BUFFER_SIZE0) tx_wr_index0=0;
#endif
   ++tx_counter0;
   }
else
   UDR0=c;
#asm("sei")
}
#pragma used-
#endif
//*************************************************************************************************
//********************END SERIAL STUFF (USART0)  **************************************************
//*************************************************************************************************
//*******   if you need USART1, enable it in Code Wizard and copy coresponding code here  *********
//*************************************************************************************************

/*
 * Timer 1 Output Compare A interrupt is used to blink LED
 */
interrupt [TIM1_COMPA] void timer1_compa_isr(void)
{
//LED1 = ~LED1; // invert LED    
}                                  

/*
 * main function of program
 */  
   GLCDINIT_t glcd_init_data; 
 int tempa, hum, sa_afiseze = 0, hum_sol;
 
 unsigned short  temp_tsh_min = 20, temp_tsh_max = 27, arh_tsh_min = 50, arh_tsh_max = 90, srh_tsh_min = 30, srh_tsh_max = 80;
bool change = 0;
unsigned int timp = 0;
unsigned short real_srh = 0;
unsigned change_time = 0;
 
void afisare(unsigned short nr){
if(nr == 0) glcd_outtextf("0");
else if(nr == 1) glcd_outtextf("1");
else if(nr == 2) glcd_outtextf("2");
else if(nr == 3) glcd_outtextf("3");
else if(nr == 4) glcd_outtextf("4");
else if(nr == 5) glcd_outtextf("5");
else if(nr == 6) glcd_outtextf("6");
else if(nr == 7) glcd_outtextf("7");
else if(nr == 8) glcd_outtextf("8");
else if(nr == 9) glcd_outtextf("9"); 
}

unsigned short sol_rh(float val){
return 100 - ((val / 5) * 100 * (val / 5) * (val / 5));
 
}

void set_temp_upper(){
        glcd_clear();
        glcd_outtextf("TMP max Treshold");
        afisare(temp_tsh_max / 10 % 10);  afisare(temp_tsh_max % 10);   glcd_outtextf("*C");
        
        change = 1;
        delay_ms(50);
}

void set_temp_lower(){
        glcd_clear();
        glcd_outtextf("TMP min Treshold");
        afisare(temp_tsh_min / 10 % 10);  afisare(temp_tsh_min % 10);   glcd_outtextf("*C");
        
        change = 1;
        delay_ms(50);
}

void set_arh_upper(){
        glcd_clear();
        glcd_outtextf("ARH max Treshold");
        afisare(arh_tsh_max / 10 % 10);  afisare(arh_tsh_max % 10);   glcd_outtextf("%");
        
        change = 1;
        delay_ms(50);
}

void set_arh_lower(){
        glcd_clear();
        glcd_outtextf("ARH min Treshold");
        afisare(arh_tsh_min / 10 % 10);  afisare(arh_tsh_min % 10);   glcd_outtextf("%");
        
        change = 1;
        delay_ms(50);
}

void set_srh_upper(){
        glcd_clear();
        glcd_outtextf("SRH max Treshold");
        afisare(arh_tsh_max / 10 % 10);  afisare(arh_tsh_max % 10);   glcd_outtextf("%");
        
        change = 1;
        delay_ms(50);
}

void set_srh_lower(){
        glcd_clear();
        glcd_outtextf("SRH min Treshold");
        afisare(srh_tsh_min / 10 % 10);  afisare(srh_tsh_min % 10);   glcd_outtextf("%");
        
        change = 1;
        delay_ms(50);
}

#define ADMUX_NOCHANNEL 0b01000000
unsigned char channel = 0;
float read_voltage() {
delay_us(10);

channel &= 0b00000111; // max 111, orice al?i bi?i tb. pu?i pe 0
ADMUX = ADMUX_NOCHANNEL | channel; // selectare canal 0 .. 7 (000 .. 111)
ADCSRA |= 0b01000000; // start conversie setînd bit ADSC=1
while (ADCSRA & 0b01000000); // a?teapta rezult; ADSC=1 în timpul conv.
ADCSRA |= 0b00010000; // ?terge flag ADIF
return (float)(ADCW) * 0.00322; // calibra?i cf. divizorului vostru !!!
}


void main(void)
{
	Init_initController();  // this must be the first "init" action/call!
	#asm("sei")             // enable interrupts
	//LED1 = 1;           	// initial state, will be changed by timer 1

  i2c_init();


// Graphic Display Controller initialization
// The SSD1306 connections are specified in the
// Project|Configure|C Compiler|Libraries|Graphic Display menu:
// /RES: PORTB Bit 2
// RS (A0) = Logic 0

// Specify the current font for displaying text
glcd_init_data.font=font5x7;
// No function is used for reading
// image data from external memory
glcd_init_data.readxmem=NULL;
// No function is used for writing
// image data to external memory
glcd_init_data.writexmem=NULL;
// Set horizontal display reverse state
//glcd_init_data.reverse_x=SSD1306_DEFAULT_REVX;
glcd_init_data.reverse_x= 1;
// Set vertical display reverse state
//glcd_init_data.reverse_y=SSD1306_DEFAULT_REVY;
glcd_init_data.reverse_y=1;
// Specify if the display is interlaced or not
glcd_init_data.interlaced=SSD1306_DEFAULT_INTERLACED;
// The Vcc voltage is generated by the internal DC/DC converter
glcd_init_data.external_vcc=SSD1306_USE_INTERNAL_DCDC;
// Set display contrast
glcd_init_data.contrast=SSD1306_DEFAULT_CONTRAST;

glcd_init(&glcd_init_data);

delay_ms(2000); //dht11 needs 2000ms ...   

while (1)
    {
glcd_setfont(courier7x14);
   status=read_dht11(&temp,&humidity);
   real_srh = sol_rh(read_voltage());
      printf("Temp:%02d H:%02d  ",temp,humidity);
       printf("V = %f\n",real_srh);
        if(pir == 1) {

            if(temp > tempa +1 || temp < temp - 1 || hum > humidity + 5 || hum < humidity - 5 || sa_afiseze == 0 || real_srh > hum_sol + 5 || real_srh < hum_sol - 5){
            sa_afiseze = 1; 
                glcd_clear();
                 afisare((temp / 10) % 10); afisare(temp % 10); glcd_outtextf("*C  ");
                     afisare((humidity / 10) % 10); afisare(humidity % 10); glcd_outtextf("%  ");
                     afisare((real_srh / 10) % 10); afisare(real_srh % 10); glcd_outtextf("%  ");
                     glcd_outtextf("TEMP  ARH  SRH");
                     //delay_ms(8000);
    }
    }
        else {
        sa_afiseze = 0;
        glcd_clear();
        }      
       // delay_ms(2000); //dht11 needs 2000ms ...
        while(timp < 2000){
        if(buton1 == 0){
        delay_ms(10);
        while (buton1 != 0);
        set_temp_lower();
        
        while(change_time < 3000){
        if(buton3 == 0){
        delay_ms(10);
        while (buton3 != 0);
        temp_tsh_min++;
        set_temp_lower();
        change_time = 0; // reseteaza mereu timpul de 3s in care poti apasa butoanele
        }
        delay_ms(1);
        change_time ++;
        
        if(buton2 == 0){
        delay_ms(10);
        while (buton2 != 0);
        temp_tsh_min--;
        set_temp_lower();
        change_time = 0;
        }
        delay_ms(1);
        change_time ++;
        
        if(buton1 == 0){ //se apasa iar B1 - se trece pe set_temp_upper  si temp_tsh_max  
         change_time = 0;
        delay_ms(10);
        //while (buton1 != 0);
        set_temp_upper();
        
        while(change_time < 3000){
         if(buton3 == 0){
        delay_ms(10);
        while (buton3 != 0);
        temp_tsh_max++;
        set_temp_upper();
        change_time = 0;
        }
        delay_ms(1);
        change_time ++;
        
        if(buton2 == 0){
        delay_ms(10);
        while (buton2 != 0);
        temp_tsh_max--;
        set_temp_upper();
        change_time = 0;
        }
        delay_ms(1);
        change_time ++; 
               
        
        
        //*************
        if(buton1 == 0){ //se apasa iar B1 - se trece pe set_arh_upper       
        change_time = 0;
        delay_ms(10);
        //while (buton1 != 0);
        set_arh_upper();
        
        while(change_time < 3000){
         if(buton3 == 0){
        delay_ms(10);
        while (buton3 != 0);
        arh_tsh_max++;
        set_arh_upper();
        change_time = 0;
        }
        delay_ms(1);
        change_time ++;
        
        if(buton2 == 0){
        delay_ms(10);
        while (buton2 != 0);
        arh_tsh_max--;
        set_arh_upper();
        change_time = 0;
        }
        delay_ms(1);
        change_time ++;
        
                if(buton1 == 0){ //se apasa iar B1 - se trece pe set_arh_lower     
        change_time = 0;
        delay_ms(10);
        //while (buton1 != 0);
        set_arh_lower();
        
        while(change_time < 3000){
         if(buton3 == 0){
        delay_ms(10);
        while (buton3 != 0);
        arh_tsh_min++;
        set_arh_lower();
        change_time = 0;
        }
        delay_ms(1);
        change_time ++;
        
        if(buton2 == 0){
        delay_ms(10);
        while (buton2 != 0);
        arh_tsh_min--;
        set_arh_lower();
        change_time = 0;
        }
        delay_ms(1);
        change_time ++; 
        
                //*************
        if(buton1 == 0){ //se apasa iar B1 - se trece pe set_srh_lower       
        change_time = 0;
        delay_ms(10);
        //while (buton1 != 0);
        set_srh_lower();
        
        while(change_time < 3000){
         if(buton3 == 0){
        delay_ms(10);
        while (buton3 != 0);
        srh_tsh_min++;
        set_srh_lower();
        change_time = 0;
        }
        delay_ms(1);
        change_time ++;
        
        if(buton2 == 0){
        delay_ms(10);
        while (buton2 != 0);
        srh_tsh_min--;
        set_srh_lower();
        change_time = 0;
        }
        delay_ms(1);
        change_time ++;
        
                if(buton1 == 0){ //se apasa iar B1 - se trece pe set_srh_upper     
          change_time = 0;
        delay_ms(10);
        //while (buton1 != 0);
        set_srh_upper();
        
        while(change_time < 3000){
         if(buton3 == 0){
        delay_ms(10);
        while (buton3 != 0);
        arh_tsh_max++;
        set_srh_upper();
        change_time = 0;
        }
        delay_ms(1);
        change_time ++;
        
        if(buton2 == 0){
        delay_ms(10);
        while (buton2 != 0);
        arh_tsh_max--;
        set_srh_upper();
        change_time = 0;
        }
        delay_ms(1);
        change_time ++; 
        }       
        }
        //**********
         
        }       
        }
        //**********  
        
        }       
        }
        //**********
         
        }       
        }
        //**********  
        }
        }
        } 
        }
        
        
        
        change_time = 0;
        timp++;
        delay_ms(1);
        
        }
        timp = 0;
        tempa = temp;
        hum = humidity;
        hum_sol = real_srh; 
         
    }
}

// read_dht11 functions
// read_dht11 functions
int read_dht11(int *temp,int *humidity){
unsigned char bytes[5];
unsigned char sum;
unsigned int bitcount=8;
unsigned int loopcount=0;
unsigned int byteid=0;
int i=0;
// EMPTY BUFFER
    for (i=0; i< 5; i++) bytes[i] = 0;
// REQUEST SAMPLE
    DHT11_OUTPUT_MODE();  
    DHT11_LOW();    
    delay_ms(20);
    DHT11_HIGH();
    delay_us(2);
    DHT11_INPUT_MODE();   
    DHT11_LOW();
    loopcount=0;    
    while(!(DHT11_PINPORT&(1<<DHT11_PIN))){ //pin is low
     delay_us(40);
     loopcount++;  
    }      
    if (loopcount>80) return DHTLIB_ERROR_TIMEOUT;
    loopcount=0;    
    while((DHT11_PINPORT&(1<<DHT11_PIN))){ //pin is high
     delay_us(1);
     loopcount++;
    }     
     if (loopcount>80) return DHTLIB_ERROR_TIMEOUT;
    for(i=0;i<40;i++){ 
    loopcount=0;    
    while(!(DHT11_PINPORT&(1<<DHT11_PIN))){}  
    while((DHT11_PINPORT&(1<<DHT11_PIN)) && loopcount<100){loopcount++;delay_us(1);}
    if(loopcount>15)
    bytes[byteid] |= (1 << bitcount);
     if (bitcount == 0)   // next byte?
        {
            bitcount = 7;    // restart at MSB
            byteid++;      // next byte!
        }
        else bitcount--; 
    } 
    *humidity    = bytes[0];
    *temp = bytes[2];
    sum = (bytes[0] + bytes[1]+ bytes[2]+ bytes[3])&0xff;  
    if (bytes[4] != sum) return DHTLIB_ERROR_CHECKSUM;  
    return DHTLIB_OK;
}

      





            
 


